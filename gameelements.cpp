#include "gameelements.h"

/**
 * 
 * Constructor of GameElements class
 * 
 **/
GameElements::GameElements() {
    trucks = new unordered_map<uint32_t, Truck>(10);
    cars = new unordered_map<uint32_t, Car>(10);
    coins = new vector<Coin>(10);
    randomGenerator = new Random();
    UID = 0;
}

/**
 * 
 * Destructor of GameElements class
 * 
 **/
GameElements::~GameElements() {
    delete trucks;
    delete cars;
    delete coins;
}


/**
 *  @param none 
 *  @return void
 * 
 *  This method generate vehicles that will transby on the tiny lanes
 *  Y coordinates will be random. Random Y coordinate will be generated by Random class
 *  Velocity of all vehicles is random that generated by Random class
 *  Generated vehicles will be stored in unordered_map and deleted from this map.
 * 
 **/
void GameElements::generateVehicles() {

    int yLine = randomGenerator->random_integer(1, 29);   
    if (yLine == 0 || yLine == 5 || yLine == 9 || yLine == 14 || yLine == 20 || yLine == 25 || yLine == 29) { 
        //printf(".... %d \n", yLine);
    } else {
        yLine = yLine * 20 + 10;
        int choice = 1 + (rand() % static_cast<int>(2 - 1 + 1));
        int dir = 1 + (rand() % static_cast<int>(2 - 1 + 1));
        //float velocity = randomGenerator->random_float(0.5, 1);
        float velocity = 7.25;
        if (choice == 1) {
            Car car(20, 20);
            if (dir == 1) {
                car.setDirection(true);
                car.setX(0);
            }
            else {
                car.setDirection(false);
                car.setX(500);
            } 
            car.setY(yLine);
            car.setVelocity(velocity);
            car.setID(++UID);
            cars->insert(make_pair(car.getID(), car));
        } else if (choice == 2) {
            Truck truck(20, 40);
            if (dir == 1) {
                truck.setDirection(true);
                truck.setX(0);
            }
            else {
                truck.setDirection(false);
                truck.setX(500);
            }
            truck.setY(yLine);
            truck.setVelocity(velocity);
            truck.setID(++UID);
            trucks->insert(make_pair(truck.getID(), truck));
        } else {
            printf("No vehicle has been generated! \n");
        } 
    }
}

/**
 * 
 * @param none
 * @return void
 * 
 * Coins are generated via this method.
 * X and Y coordinate of coins are generated randomly by Random class
 * Coins will be stored in a vector and will be deleted from this vector
 * 
 **/
void GameElements::coinGeneration() {
    coins->clear();
    glColor3f(1.0f, 1.0f, 0.0f);
    for(int c = 0; c < 10; c++) {
        int x = 10 + (rand() % static_cast<int>(500 - 10 + 1));
      int y = randomGenerator->random_integer(1, 29);
      y = y * 20 + 10;
      Coin coin;
      coin.setX(x);
      coin.setY(y);
      coins->push_back(coin);
      if (c == 9) {
         break;
      }
   }
}

/**
 * @param none
 * @return void
 * 
 * Coins are destroyed in this method.
 * Timing for destroying coins are set in crossroad.cpp
 * 
 **/
void GameElements::coinDestruction() {
    coins->clear();
}

/**
 * @param none
 * @return void
 * 
 * Trucks will be displayed to screen.
 * Getting trucks information via iterating map.
 * 
 * */
void GameElements::drawTrucks() {
    glColor3f(0.534, 0.653, 0.78);
    for(auto it = trucks->begin(); it != trucks->end(); it++) {
      int x = it->second.getX();
      int y = it->second.getY();

      glBegin(GL_POLYGON);
         glVertex2f(x - 20, y + 10);
         glVertex2f(x + 20, y + 10);
         glVertex2f(x + 20, y - 10);
         glVertex2f(x - 20, y - 10);
      glEnd();
    }
}

/**
 * @param none
 * @return void
 * 
 * Cars will be displayed to screen.
 * Getting cars information via iterating map.
 * 
 * */
void GameElements::drawCars() {
    glColor3f(0.87, 0.53, 0.23);
    for(auto it = cars->begin(); it != cars->end(); it++) {
        int x = it->second.getX();
        int y = it->second.getY();

        glBegin(GL_POLYGON);
            glVertex2f(x - 10, y + 10);
            glVertex2f(x + 10, y + 10);
            glVertex2f(x + 10, y - 10);
            glVertex2f(x - 10, y - 10);
        glEnd();
    }
}

/**
 * @param none
 * @return void
 * 
 * Coins will be displayed to screen.
 * Getting coins information via iterating vector.
 * 
 * */
void GameElements::drawCoins() {
    glColor3f(1.0f, 1.0f, 0.0f);
    for(auto &coin : *coins) {
      glBegin(GL_POLYGON);
      for(double i = 0; i < 2 * PI; i += PI / 36) //<-- Change this Value
          glVertex3f(coin.getX() + cos(i) * RADIUS, coin.getY() + sin(i) * RADIUS, 0.0);
        glEnd();
    }
}

/**
 * @param none
 * @return void
 * 
 * Passing vehicles will be drawn by this method.
 * CAUTION : Since cars and trucks have different speed, collision may occur in same lane!
 * If cars or trucks out of screen by X coordinate, they will be removed from maps.
 * 
 * */
void GameElements::passingVehicles() {
    vector<uint32_t> *idList = new vector<uint32_t>(cars->size());

    for(auto it = cars->begin(); it != cars->end(); it++) {
        if(it->second.getDirection() == true) {
            it->second.setX(it->second.getX() + it->second.getVelocity() * 5);
            if (it->second.getX() >= 500) {
                idList->push_back(it->first);
            }
        } else {
            it->second.setX(it->second.getX() - it->second.getVelocity() * 5);
            if (it->second.getX() <= 0) {
                idList->push_back(it->first);
            }
        }
    }

    for(auto key : *idList) {
        cars->erase(key);
    }

    for(auto it = trucks->begin(); it != trucks->end(); it++) {
        if(it->second.getDirection() == true) {
            it->second.setX(it->second.getX() + it->second.getVelocity() * 5);
            if (it->second.getX() >= 500) {
                idList->push_back(it->first);
            }
        } else {
            it->second.setX(it->second.getX() - it->second.getVelocity() * 5);
            if (it->second.getX() <= 0) {
                idList->push_back(it->first);
            }
        }
    }

    for(auto key : *idList) {
        trucks->erase(key);
    }

    delete idList;
}

/**
 * @param Truck otherTruck, User user
 * @return bool -> true or false according to collision status
 * 
 * otherTruck's and users coordinates are compared.
 * If any collision occurs, return true. If not, return false
 * Checks collisions from both sides of user.
 * 
 * */
bool GameElements::checkTruckCollision(Truck &otherTruck, User &user) {
    bool collisionY = false;

    float userX = user.getX();
    float userY = user.getY();

    float userXMinusTen = user.getX() - 10;
    float userXPlusTen = user.getX() + 10;

    float truckXMinusThirty = otherTruck.getX() - 30;
    float truckXPlusThirty = otherTruck.getX() + 30;

    collisionY = user.getY() >= otherTruck.getY() && otherTruck.getY() >= user.getY();

    if(isInRange(userX, truckXMinusThirty, truckXPlusThirty) && collisionY)
        return true;
    else 
        return false;
}

/**
 * @param Car otherCar, User user
 * @return bool -> true or false according to collision status
 * 
 * otherCar's and users coordinates are compared.
 * If any collision occurs, return true. If not, return false
 * Checks collisions from both sides of user.
 * 
 * */
bool GameElements::checkCarCollision(Car &otherCar, User &user) {
    bool collisionY = false;

    float userX = user.getX();
    float userY = user.getY();

    float userXMinusTen = user.getX() - 10;
    float userXPlusTen = user.getX() + 10;

    float carXMinusTwenty = otherCar.getX() - 20;
    float carXPlusTwenty = otherCar.getX() + 20;

    collisionY = user.getY() >= otherCar.getY() && otherCar.getY() >= user.getY();

    if(isInRange(userX, carXMinusTwenty, carXPlusTwenty) && collisionY)
        return true;
    else 
        return false;
}

/**
 * @param Coin coin, User user
 * @return bool -> true or false according to collision status
 * 
 * coin's and users coordinates are compared.
 * If any collision occurs, return true. If not, return false
 * Checks collisions from both sides of user.
 * If any collision occurs, coin will be collected
 * 
 * */
bool GameElements::checkCoinCollision(Coin &coin, User &user) {
    bool collisionXLeft = false;
    bool collisionXRight = false;
    bool collisionY = false;

    collisionXLeft = user.getX() + 10 >= coin.getX()  && user.getX() <= coin.getX();
    collisionXRight = user.getX() -10 <= coin.getX()  && user.getX()  >= coin.getX();
    collisionY = user.getY() >= coin.getY() && coin.getY() >= user.getY();

    return (collisionXLeft || collisionXRight) && collisionY;
}

/**
 * @param User user
 * @return bool -> return if collision occurred or nor
 * 
 * Checks both car and truck collision 
 * If crash happens, game will be over
 * 
 * */
bool GameElements::isCrashed(User &user) {
    
    for(auto it = trucks->begin(); it != trucks->end(); it++) { 
      if (checkTruckCollision(it->second, user))
         return true;
   }

   for(auto it = cars->begin(); it != cars->end(); it++) { 
      if (checkCarCollision(it->second, user)) 
        return true;
    }
    return false;
}

/**
 * @param User user
 * @return bool -> return if collision occurred or nor
 * 
 * Checks coin collision 
 * If collision happens, 5 points will be collected
 * Collected coin will be removed from vector
 * 
 * */
bool GameElements::isCollectedCoin(User &user) {
    bool collected = false;
    for(int i = 0; i < coins->size(); i++) {
        if(checkCoinCollision(coins->at(i), user)) {
            coins->erase(coins->begin() + i);
            return true;
        }
   }
   return collected;
}


/**
 * @param float num, float min, float max
 * @return true or false
 * 
 * Checks if given number num is range between min and max
 * */
bool GameElements::isInRange(float num, float min, float max) {
    if (num <= max && num >= min) 
        return true;
    else 
        return false;
}